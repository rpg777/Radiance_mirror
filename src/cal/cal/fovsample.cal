{ RCSid $Id: fovsample.cal,v 1.1 2019/04/05 00:17:24 greg Exp $ }
{
	Foveated sampling based on central direction vector,
	magnification factor at center, and central field of view.

	Greg Ward	April 2019

	Constants:
		Cx, Cy, Cz :	central view direction
		D :		field of view (full angle in degrees)
		M :		central FOV magnification factor

	Inputs:
		iDx, iDy, iDz =	uniformly generated sampling vector
	
	Outputs:
		oDx, oDy, oDz =	foveated sample direction (normalized)
	
	Other variables computed:
		iTheta =	original angle to center (radians)
		oTheta =	modified angle to center (radians)
}
r : PI/360 * D;
rp : M * r;
len(x,y,z) : sqrt(x*x + y*y + z*z);

Clen : len(Cx,Cy,Cz);
nCx : Cx/Clen;
nCy : Cy/Clen;
nCz : Cz/Clen;

iDnf = 1/len(iDx,iDy,iDz);
niDx = iDx*iDnf;
niDy = iDy*iDnf;
niDz = iDz*iDnf;

iDot = nCx*niDx + nCy*niDy + nCz*niDz;
degen = iDot - cos(.01*PI/180);
iTheta = acos(iDot);

gacc : 2;		{ gamma acceleration needed for C1 continuity }

gamma = 1 + ((iTheta-rp)/(PI-rp))^gacc*(log(M)/(log(PI/(PI-r)) - log(M)));

oTheta = if(rp-iTheta, iTheta/M,
		r + (PI-r)*((iTheta/(M*(PI-r)))^gamma - r/(PI-r)));

Unf = 1/sqrt(1 - iDot);
nUx = (nCy*niDz - nCz*niDy)*Unf;
nUy = (nCz*niDx - nCx*niDz)*Unf;
nUz = (nCx*niDy - nCy*niDx)*Unf;
			{ rotate central vector by oTheta }
vPx = nUy*nCz - nUz*nCy;
vPy = nUz*nCx - nUx*nCz;
vPz = nUx*nCy - nUy*nCx;
rcos = cos(oTheta);
rsin = sin(oTheta);

rDx = nCx*rcos + nUx*(1-rcos) + vPx*rsin;
rDy = nCy*rcos + nUy*(1-rcos) + vPy*rsin;
rDz = nCz*rcos + nUz*(1-rcos) + vPz*rsin;

oDx = if(degen, nCx+(niDx-nCx)/M, rDx);
oDy = if(degen, nCy+(niDy-nCy)/M, rDy);
oDz = if(degen, nCz+(niDz-nCz)/M, rDz);
