{ RCSid $Id: fovsample.cal,v 1.3 2019/04/05 23:49:59 greg Exp $ }
{
	Foveated sampling based on central direction vector,
	magnification factor at center, and central field of view.

	Greg Ward	April 2019

	Preset constants:
		Cx, Cy, Cz :	central view direction
		M :		central FOV magnification factor
		D :		field of view (full angle in degrees)

	Inputs:
		iDx, iDy, iDz =	uniformly generated sampling vector
	
	Outputs:
		oDx, oDy, oDz =	foveated sample direction (normalized)
	
	Other variables computed:
		iTheta =	original angle to center (radians)
		oTheta =	new angle to center (radians)
}

r : PI/360 * D;		{ half-angle of foveal region in radians }
rp : M * r;		{ half-angle of mapped boundary }

len(x,y,z) : sqrt(x*x + y*y + z*z);
sq(x) : x*x;
			{ normalize central vector }
Clen : len(Cx,Cy,Cz);
nCx : Cx/Clen;
nCy : Cy/Clen;
nCz : Cz/Clen;
			{ normalize input direction }
iDnf = 1/len(iDx,iDy,iDz);
niDx = iDx*iDnf;
niDy = iDy*iDnf;
niDz = iDz*iDnf;
			{ check for degenerate case (center of fovea) }
iDot = nCx*niDx + nCy*niDy + nCz*niDz;
degen = iDot - cos(.05*PI/180);

iTheta = acos(iDot);

gamma = 1 + sq((iTheta-rp)/(PI-rp)) * (log(M)/(log(PI/(PI-r)) - log(M)));

oTheta = if(rp-iTheta, iTheta/M, (PI-r)*(iTheta/(M*(PI-r)))^gamma);

			{ normalized "up" vector for rotation }
Unf = 1/sqrt(1 - iDot*iDot);
nUx = (nCy*niDz - nCz*niDy)*Unf;
nUy = (nCz*niDx - nCx*niDz)*Unf;
nUz = (nCx*niDy - nCy*niDx)*Unf;
			{ rotate central vector by oTheta to get new output }
rcos = cos(oTheta);
rsin = sqrt(1 - rcos*rcos);
			{ foveated sample direction }
rDx = nCx*rcos + (nUy*nCz - nUz*nCy)*rsin;
rDy = nCy*rcos + (nUz*nCx - nUx*nCz)*rsin;
rDz = nCz*rcos + (nUx*nCy - nUy*nCx)*rsin;
			{ substitute approximation in degenerate case }
oDx = if(degen, nCx+(niDx-nCx)/M, rDx);
oDy = if(degen, nCy+(niDy-nCy)/M, rDy);
oDz = if(degen, nCz+(niDz-nCz)/M, rDz);
